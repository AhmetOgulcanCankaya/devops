SQL nedir nasıl kullanılır ?

SQL ilişkisel veritabanı yönetiminde kullanılan bir dildir.
İlişkisel veritabı birbirleri arasında bağlantıları bulunan tablolara sahip veritabanlarına denir.
Column-sütun: Objelerin sahip olduğu veri tipleri olarak düşünebiliriz.Field olarak da adlandırabiliriz.
Sütunlardan bir tanesi satırları-kayıtları birbirinden ayırabilmek için genellikle eşsiz-unique bir anahtar içerir.
Bazen tablolar arasında bağlantılar kurmamız ve belirli field'ları başka bir tablo ile bağlantılı olarak kullanmamız gerekebilir.
Bu tarz durumlarda foreign-key'leri kullanırız. FK'ler bizlere başka tablolardaki Primary-unique öncül-eşsiz key'lere referans yapmamıza yardımcı olurlar.

SELECT
	SELECT anahtarının asıl amacı adından da anlaşılacağı gibi belirli verileri seçmektir.
	SELECT 'Hello, World';  --> bu komutun geri döndüreceği sonuç 'Hello, World' tablosundan 'Hello World' olacaktır.Tablo bizde var olmasa dahi.
		Bunun sebebi ise SQL'in SELECT anahtarının yanında verilen 'Hello World'ü bir satır olarak almış olması olacaktır
	SELECT 'Hello' AS Result; --> ise bize Result tablosundan 'Hello'yu getirecektir.
	SELECT * FROM Country; --> Gerçek hayat kullanımlarından bir tanesi olan SELECT * ise FROM anahtarından sonra gelen tablo adı içerisindeki bütün satırları getirecektir.
		FROM anahtarı ile verinin nereden alınmasını istediğimizi belirtebiliriz.
	SELECT * FROM Country ORDER BY Name; --> Burada ORDER BY anahtarı ile ise belirli Field'lara göre sıralama yaparak sonuçlarımızı alabilriiz.
		Burada * aslen regex ifadelerindeki gibi "her biri" anlamını taşır. Nitekim * yerine Name,Code,etc kullanırsanız tablonun içerisindeki 
		Name,Code,etc field'larını geri dönecektir. Alias (takma isim) kullanmanız da mümkündür. 
		SELECT Code AS "Country Code" FROM Country ORDER BY Name; sorgusunu kullanarak dönen yanıt içerisinde sonuçlarınızı istediğiniz isimle görebilirsiniz.
	SELECT * FROM customer WHERE name IS NOT NULL; buradaki sorgu aşağıda bahsedilen NULL değerinin customer tablosunun name alanında bulunmayan 
		satırlarını bize döndürecektir.
	SELECT Continent FROM Country; Ülkeler tablosundaki bütün ülkerin kıtalarını bize döndürecektir. Ancak DISTINCT anahtarını eklersek bize dönecek kayıtlar kendi 
		aralarında eşsiz satırlar olarak ayrılacak ve bize eşsiz olanlar gösterilecektir. 
			"" SELECT DISTINCT Continent FROM Country; ""
WHERE
	SELECT Name,Continent,Region FROM Country WHERE Continent = 'Europe' --> sorgusu bizlere Country tablosunda Continent alanı Europe olan kayıtların 
		sadece Name,Continent,Region alanlarını dönecektir.
	SELECT Name,Continent,Region FROM Country WHERE Continent = 'Europe' ORDER BY Name LIMIT 5 OFFSET 5 --> Burada ise Europe kaydı olan satırlar içerisinde 
		Name alanına göre sıralama yapıp sonrasında ise ilk 5 kaydı aldık. Ancak OFFSET verdiğimiz için kayıtlar sıralandıktan sonraki ilk 5 kaydı görmezden gelmek zorunda kaldık.

Buradaki anahtar kelimelerin sıralanışına dikkat etmemiz gerekmekte.Sırasıyla FROM, WHERE, ORDER, LIMIT, OFFSET olması gerekmekte. 
Veritabanları arasında değişiklik gösterebilse dahi çoğu operasyonun çalışmama ihtimali olabilir yanlış sıralamalar söz konusu olduğunda.

ORDER
	SELECT operasyonu sonucu ortaya çıkan çıktıyı sıralamamız mümkün. Anahtar kelimemiz ORDER BY olacak.
	SELECT Name FROM Country ORDER BY Name; Ülkeler tablosunu isme göre sıralayarak bize döndürecektir. 
	SELECT Name FROM Country ORDER BY Name [ASC|DESC]; Artan veya azalan sırada sıralamak için ASC veya DESC kelimelrini kullanıyoruz.
	SELECT Name,Continent FROM Country ORDER BY Continent DESC, Name; Buradaki sorgumuzda ise ilk olarak kıtalar içerisinde sıralama yapıyor ve kıtaların DESC
		sıralaması içerisinde ülke isimlerini artan şekilde sıralıyoruz. Artış ve azalış ASCII tablosundaki değerlere göre belirlenmekte.
COUNT
	SELECT COUNT(*) FROM Country; sorgusu bize Country tablosundaki kayıtların toplam sayısını dönecektir.
	SELECT COUNT(*) FROM Country WHERE X = 1; sorgusu ise tahmin edebileceğimiz gibi X alanı 1 olan kayıtların sayısını dönecektir.
	SELECT COUNT(Code) FROM Country; sorgusu ise bize Code alanında veri olan alanları döndürür.

INSERT
	INSERT INTO customer (name, address, city, state, zip) VALUES ('Fred','Earth','Bedrock','CA','91234'); sorgusu verdiğimiz bilgileri customer isimli tabloya ekler.
	INSERT INTO customer VALUES ("Velma","Earth","Mystery Inc","USA","00007"); sorgusu customer tablosunda sadece "name, address, city, state, zip" 
		alanlarının bulunması halinde bir satır ekleyecektir.
	INSERT INTO customer (name,address) VALUES("Scooby","Dog Park"); sorgusu ise city,state,zip alanlarını boş bırakacak şekilde bir kayıt ekleyecektir.
	INSERT INTO customer DEFAULT VALUES; sorgusu tabloya oluşturulma sırasında atanmış temel değerleri ekleyecektir. Temel değer belirtilmediğinde ise 
		"NULL" değeri atanacaktır.
	INSERT INTO customer (name, address, city) SELECT name, address, country FROM oldCustomers; sorgusu bizim için oldCustomers tablosundaki değerleri 
		customer tablosuna atayacaktır. Bu şekilde de SELECT sorgusundan dönen yanıtların INSERT operasyonuna eklenmiş olduğunu görebiliyoruz.
	
UPDATE
	UPDATE customer SET address = 'Mars' WHERE id = 5 ; buradaki sorguda yukarıda bahsedilen primary anahtarlardan yararlanılarak primary anahtarı 
		"5" olan kaydın address alanını "Mars" olarak güncelledik.
	UPDATE customer SET x=y, h=g, f= NULL WHERE id = 5 ; burada ise özel bir veri olan NULL'u yani hiçliği kullandık ve birden fazla alanı aynı zamanda düzenledik.
DELETE
	DELETE FROM customer WHERE id = 5; UPDATE operasyonunda olduğu gibi DELETE operasyonunda da da primary anahtarlardan yararlandık.
	DELETE FROM customer Where name = "Fred"; bu sorguda ise name alanı Fred olan bütün satırları sileceğiz. 
		Aralarındaki fark ise id'nin öncelikli bir anahar olabilir ve sadece tek bir kaydın silinmesinde kullanılabilmesidir.
CREATE
	CREATE TABLE table_name (fieldA INTEGER, fieldT TEXT); bu tarz sorguları parantezler arasında belirttiğimiz tablo şemasına uygun bir biçimde 
		bir veritabanı tablosu oluşturmak için kullanırız.
	CREATE TABLE table_name (fieldA INTEGER NOT NULL, fieldT TEXT NOT NULL); burada yaratılan tabloda INSERT operasyonunu kullanmak istediğimizde 
		yanında NOT NULL yazan değerlere NULL değeri veremez veya onları es geçemeyiz.
DROP
	DROP TABLE table_name; DROP operasyonu ismi table_name olan belirttiğimiz tipi (table) veritabanından siler.
	DROP TABLE  IF EXISTS table_name; operasyonu ise tablonun halihazırda var olmaması halinde size hata mesajı ile geri dönüşte bulunmaz.
NULL
	NULL kelime anlamı olarak aslen "hiçlik" olan ve veritabanlarında çoğunlukla sıfır veya boşluk halinde gösterilmeyen ve asıl anlamı 
		veritabanları için "değerin yokluğu" olarak düşünülebilir.
CONSTRAINTS
	CREATE TABLE test (a TEXT, b TEXT, c TEXT DEFAULT 'panda'); sorgusu ile oluşturulan test tablosunda INSERT işlemi yapılması halinde 
		c alanında veri olmaması halinde alana veritabanı tarafından otomatik olarak 'panda' değeri eklenecektir.
	CREATE TABLE test (a TEXT UNIQUE, b TEXT, c TEXT DEFAULT 'panda'); yukarıda oluşturulan tablodan farklı olarak artık INSERT işleminde
		tabloya eklenecek değerlerden a değerinin tabloda olmamasına dikkat edilecek ve olması halinde veritabanı tarafından hata verilecek.
		Sistemler arası değişmekle birlikte NULL değerinin tekrar tekrar eklenebilme durumu söz konusu olabilir. Bu durum değişkendir.
	CREATE TABLE test (a TEXT UNIQUE, b TEXT NOT NULL, c TEXT DEFAULT 'panda'); yukarıdaki sorgu ile farkını anlayabilirsiniz. b alanına NULL değer gelemez.
	CREATE TABLE test (id INTEGER PRIMARY KEY, b INTEGER, c TEXT DEFAULT 'panda'); öncül anahtarlardan bahsetmiştik. Bir tabloda kayıtların birbirlerinden 
		farklılaşmalarını sağlayan alanlardır. Burada ise primary-öncül anahtarımızı oluşturmanın yöntemini göstermiş bulunmaktayız. Yeni eklenen kayıtlarda
		id alanına ekleme olmaması halinde dahi her kayıtta id alnında bir değer göreceğiz. id adına sahip alanların özel alanlar olarak işaretlenmiş
		olabileceklerini belirtmekte fayda var.
FILTERING
	Filtreleme işlemini SELECT operasyonuna bğlı olarak kolaylıkla yapabiliriz.
	SELECT Name, Continent, Population FROM Country WHERE 
		Population < 10000000 ORDER BY Population DESC; Buradaki sorguda Ülkelerin bulunduğu tabloda filtrelemeli aramalar yapabiliriz.
	Filtreleme işlemlerinde Boolean-mantıksal işlemler yapabilmemiz de mümkündür.
	SELECT Name, Continent, Population FROM Country WHERE [FILTERS] ORDER BY Population DESC;
	Filtreleme işleminin ana kısmı [FILTERS] olarak belirtilen alanlar olarak düşünüldüğünde, "Population < 1000000 OR Continent = 'Africa' AND Name IS NOT NULL" 
		şeklinde belirtilen bir filtre olması halinde gelecek olan kayıtların karşılaması gereken birtakım koşullar olacaktır.
		(Nüfusu 1 milyondan az ve Name alanı NULL olmayan ülkeler) veya (Name alanı boş olmayan Afrika kıtasındaki ülkeler) şeklinde düşünülebilir. 
	SELECT Name, Continent, Population FROM Country WHERE Name LIKE '%island%' ORDER BY Name; buradaki sorguda ise Name alanındaki satırın içinde 
		island kelimesi geçen kayıtları göreceğiz. Burada % işareti herhangi bir karakter dizisi anlamında kullanılmaktadır. 
	SELECT Name, Continent, Population FROM Country WHERE Name LIKE '_a%' ORDER BY Name; Bu sorguda ise _ işareti tek bir karakterin yerine kullanılmıştır.
		Anlamı ise Name alanındaki satırda ikinci harfin a olması durumunda kaydın seçilmesidir.
	SELECT Name, Continent, Population FROM Country WHERE Continent IN ('Europe', 'Asia') ORDER BY Name; Buradaki sorguda IN belirteçinden sonra gelen
		kümede var olan kelimeler kayıtlar arasında Continent alanında bulunması gereken kelimeleri içermektedir. Basitleştirmek gerekirse, 
		Continent alanında Europe veya Asia gördüğümüz kayıtlar sorgumuz sonucu bize dönecek olan kayıtlardır.
ALTER
	ALTER TABLE test ADD d TEXT; buradaki sorguda görebiliriz ki burada test tablosuna d alanını ekliyoruz. Burada önceden bulunan kayıtlarda ise 
		d alanı NULL olarak görülecektir.
	ALTER TABLE test ADD d TEXT DEFAULT 'panda'; sorgusunda ise d alanı önceden var olan kayıtlara 'panda' değeri ile eklenecektir.

CONDITIONS
	Koşullandırmalarda dikkat edilmesi gerekmekte.
	Burada vereceğimiz örnek için elimizde bir "test" tablosu olduğunu düşünelim. test tablosunda a ve b alanları bulunmakta ve iki adet kayıt vardır.
	------------
	|  | a | b | Bu şekilde bir tablomuz olması halinde kullanacağımız koşullandırmalar ve sonuçları belirtilen şekillerde olacaktır.
	------------
	|1 | 1 | 0 | Koşul 1: CASE a WHEN 1 THEN 'true' ELSE 'false' END CASE b WHEN 1 THEN 'true' ELSE 'false' END ; sorgusu sonuç olarak bu satır için
	------------			"true" ve "false" sonuçlarını içeren bir satır dönecektir.
	|2 | 0 | 1 |Koşul 1: CASE WHEN a THEN 'true' ELSE 'false' END CASE WHEN b THEN 'true' ELSE 'false' END ; sorgusu sonuç olarak bu satır için
	------------			"false" ve "true" sonuçlarını içeren bir satır dönecektir. Yukarıdakinden farkı ise WHEN kullanımıdır.
		WHEN kullanımında "WHEN a" verildiğinde standart SQL bizim için a alanının 0 olması halinde false değerini üretecektir.

İlişkisel sorgular

JOIN
	Join işlemini kullanabilmek için birbiri ile ilişkili tabloları bir Venn diagramı şeklinde hayal etmeniz gerekmekte.
	Bu sırada sağ ve sol tabloyu, kesişimlerini ve farklarını veritabanlarında gösterebileceğimizi unutmayın.
	left ve right adında iki tablomuz olduğunu ve bu iki tabloda da id ve txt alanlarının olduğunu düşünelim.

	SELECT l.txt, r.txt FROM left AS l JOIN right AS r ON l.id = r.id; Buradaki sorgu left/right tablosunu l/r adı ile düşünerek txt alanını almak için
		left ve right tablolarındaki id kısımlarının eşit id'lerini alıp bize bu satırlardan left/right tablosuna ait olan txt alanlarını döndürür.
	SELECT l.txt, r.txt FROM left AS l LEFT JOIN right AS r ON l.id = r.id; Buradaki satırda ise koşulun sağlanmaması halinde dahi bir dönüş sağlanacaktır.
		Yukarıdakinden farkı ise r.txt olması gereken alanlarda NULL değerini göreceğimizdir.

	SELECT c.name AS Cust, c.zip, i.name AS Item, i.description, s.quantity AS Quan, s.price AS Price
		FROM sale AS s
		JOIN item AS i ON s.item_id = i.id
		JOIN customer AS c ON s.customer_id = c.id
		ORDER BY Cust, Item;					Buradaki yarı komplex sorguyu inceleyebilirsiniz.

String
	Veri tiplerinden biri olan String bir karakter dizisi olarak düşünülebilir. String kullanımlarında 
		platform bazlı değişimler olacaktır. Kullandığınız platformlara göre incelemeniz gerekecektir.
